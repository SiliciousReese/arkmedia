# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_VideoCopy.ipynb (unless otherwise specified).

__all__ = ['Video', 'YTVideo', 'parseCLI']

# Cell
from pytube import YouTube, Stream, Caption
import psycopg2 as psql
import argparse
from pathlib import Path

# Cell
class Video:
    link=""
    _workingdir = Path('.')

    def start(self):
        print("ToDo")
        self.fixLink()

    def fixLink(self):
        pass

    @property
    def workingdir(self):
        return self._workingdir

    @workingdir.setter
    def workingdir(self,newdir):
        self._workingdir = Path(newdir)


# Cell
class YTVideo(Video):
    VID_ORDER = {0:'avc', 1:'vp9'}
    def __init__(self,filename = "temp", ytlink="", tube: YouTube = None):
        self.vid = None
        self.tempfilename = filename
        if not tube is None:
            self.vid = tube
        elif ytlink:
            self.link=ytlink
            self.fixLink()
            self.vid = YouTube(self.link)

        self.streams = {}

        self.tempfiles = {}

    def start(self):
        super().start()

    def fixLink(self):
        if not "https://www.youtube.com/" in self.link:
            print("Not YT")
    def parseStreams(self):
        self.streams['v'] = self.pickVid()
        self.streams['a'] = self.pickAudio()
        #print(self.streams)
        caps = self.parseCaptions()
        #print(caps)
        self.streams = {**self.streams, **caps}


    def pickVid(self):
        s = self.vid.streams

        #Filter out video streams, pick the "best" one by resolution, fps, and codec
        maxres = str(max([int((x.resolution or '000')[:-1]) for x in s.filter(only_video=True)]))+'p'
        #print("Max Res: ", maxres)
        maxfps = max([x.fps for x in s.filter(only_video=True,res=maxres)])
        #print("Max FPS: ", maxfps)
        cstreams = s.filter(only_video=True,res=maxres,fps=maxfps)
        #itags_bycodec = {x:0 for x in self.VID_ORDER.values()}
        #print(self.VID_ORDER)
        itag = 0
        for cd in self.VID_ORDER:
            if itag:
                break
            for st in cstreams:
                #print(self.VID_ORDER[cd])
                if self.VID_ORDER[cd] in st.video_codec:
                    #print("Picking: ", st.itag,st.video_codec)
                    itag = st.itag
                    break
                print (st.itag,st.video_codec)
        return s.itag_index[itag]

    def pickAudio(self):
        #Filter out audio stream, pick the "best" on by audio bit rate
        #picks first best codec, FIXME
        s = self.vid.streams
        maxadp = max([int(x.abr[:-4]) for x in s.filter(only_audio=True)])
        #print(maxadp)
        astreams = s.filter(only_audio=True, abr=str(maxadp)+"kbps")
        #print(astreams[0])
        return astreams[0]

    def parseCaptions(self):
        caps = {}
        for t in self.vid.caption_tracks:
            lang = t.code
            if "auto" in t.name:
                #print("auto")
                lang = 'a-' + lang
            #print(lang)
            caps['c-' + lang] = t
        return caps

    def downloadStreams(self):
        for s in self.streams:
            st = self.streams[s]

            print (s,st)

            if isinstance(st,Stream):
                fname = st.download(output_path = self.workingdir, filename = self.tempfilename, filename_prefix = s + '-')
            else:
                fname = st.download(filename_prefix=s + '-',title = self.tempfilename,output_path = self.workingdir)
                file = Path(fname)
                newname = str(s) + '-' + self.tempfilename + ".srt"
                newpath = file.parent
                file.rename(Path(newpath,newname))
                fname = Path(newpath,newname)
            print("File: ", fname)
            self.tempfiles[s] = Path(fname)


# Cell
def parseCLI():
    progname = "VideoCopy"
    par = argparse.ArgumentParser(progname)

    par.add_argument("-v", help="Link to video")
    args = par.parse_args()

    return None


# Cell
# notest
#print(__name__)
if __name__ == "__main__":
    job = parseCLI()
    if job:
        pass
        #job.start